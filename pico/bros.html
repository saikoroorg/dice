<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1" />
<title>PicoBros</title>
<link rel="icon" type="image/svg" href="icon.svg" />
<link rel="apple-touch-icon" href="icon.png" sizes="192x192" />
<link rel="manifest" href="manifest.json" />
<link rel="stylesheet" href="stylesheet.css" />
</head>
<body>
<div id="container">
	<h1 id="header">
		<div class="logo">
			<a id="title" href="./index.html">Pico</a>
			<a id="subtitle" href="javascript:top.location.reload();">Bros</a>
		</div>
		<div class="menu center">
			<a class="item light secret" id="action" href="javascript:menuAction();">
				<span id="actionText"></span>
				<img class="icon" id="actionIcon" src="" />
			</a>
		</div>
		<div class="menu">
			<a class="item clear" id="minus" href="javascript:menuSelect(-1);">-</a>
			<a class="item light" id="select" href="javascript:menuSelect(0);">
				<span id="selectText"></span>
				<img class="icon" id="selectIcon" src="" />
			</a>
			<a class="item clear" id="plus" href="javascript:menuSelect(+1);">+</a>
		</div>
	</h1>
	<div id="contents">
		<div id="screen" class="picoImage picoTouch"></div>
	</div>
</div>
<h6 id="footer">
	<div id="author"></div>/
	<div id="version"></div>
</h6>
<script>console.log = () => {};</script>
<script src="daemon.js"></script>
<script src="image.js"></script>
<script src="param.js"></script>
<script src="sound.js"></script>
<script src="touch.js"></script>
<!--Data--><script>
var levels = [ // Level data.
[0,7,7,1,0,0,2,6,6], //"Bros",
[0,7,7,1,0,0,2,6,6,4,6,0,4,0,6], //"Block",
[0,7,7,1,0,0,2,6,6,4,1,1], //"Pole",
[0,7,7,1,0,0,2,6,6,4,5,1,4,5,2,4,5,3,4,5,4,4,1,5,4,2,5,4,3,5,4,4,5,4,5,5], //"Wall",
[0,7,7,1,2,2,2,4,4,4,2,3,4,2,4,4,3,4], //"Boomerang",
[0,7,7,1,0,6,2,6,6,4,3,2], //"Cracker",
[0,7,7,1,0,0,2,4,4,4,2,2,4,3,2,4,5,2,4,6,2,4,2,3,4,6,3,4,2,4,4,6,4,4,2,5,4,6,5,4,2,6,4,3,6,4,4,6,4,5,6,4,6,6], //"Room",
[0,7,7,1,0,0,2,4,4,4,1,1,4,5,1,4,5,2,4,5,3,4,5,4,4,1,5,4,2,5,4,3,5,4,4,5,4,5,5], //"Inside",
[0,7,7,1,1,1,2,5,1,4,3,3], //"Belly",
[0,7,7,1,1,3,2,5,3,4,3,5], //"Baby",
[0,7,7,1,2,3,2,4,3,4,0,0,4,6,0,4,0,3,4,6,3,4,0,6,4,3,6,4,6,6], //"Urchin",
[0,7,7,1,2,3,2,4,3,4,0,0,4,6,0,4,0,5,4,3,5,4,6,5,4,0,6,4,3,6,4,6,6], //"Shaggy",
[0,7,7,1,2,6,2,4,6,4,0,0,4,6,0,4,0,5,4,6,5,4,0,6,4,1,6,4,5,6,4,6,6], //"Crab",
[0,7,7,1,0,0,2,6,6,4,1,2,4,5,2], //"Asymmetry",
[0,7,7,1,1,1,2,5,1], //"Eyes",
[0,7,7,1,1,1,2,5,1,4,2,3,4,3,3,4,4,3], //"Raise",
[0,7,7,1,2,2,2,4,2,4,3,2,4,2,3,4,4,3,4,2,6,4,4,6], //"Horseshoe",
[0,7,7,1,2,2,2,4,2,4,2,4,4,3,4,4,4,4], //"Face",
[0,7,7,1,1,1,2,5,1,4,1,3,4,2,3,4,3,3,4,4,3,4,5,3], //"Teeth",
[0,7,7,1,1,1,2,5,1,4,1,4,4,5,4,4,1,5,4,2,5,4,3,5,4,4,5,4,5,5], //"Smile",
[0,7,7,1,1,2,2,5,2,4,1,1,4,5,1,4,1,5,4,5,5], //"Mask",
[0,7,7,1,3,2,2,2,3,4,2,0,4,0,2,4,2,2], //"Scissor",
[0,7,7,1,6,4,2,4,6,4,3,0,4,3,2,4,4,2,4,0,3,4,2,3,4,3,3,4,4,3,4,2,4,4,3,4,4,4,4], //"Turtle",
[0,7,7,1,2,1,2,1,2,4,2,2,4,4,2,4,2,4,4,4,4], //"Cross",
[0,7,7,1,1,1,2,5,5,4,3,1,4,3,2,4,1,3,4,2,3,4,3,3], //"Sling",
[0,7,7,3,1,5,4,1,3,4,3,5], //"Unite",
[0,7,7,1,1,5,2,5,1,4,2,1,4,1,2,4,2,2], //"Balance",
[0,7,7,3,3,2,4,3,4], //"Jump",
[0,7,7,3,3,3,4,3,4], //"Ignition",
[0,7,7,1,1,1,2,5,1,4,1,2,4,2,2,4,4,2,4,5,2,4,2,4,4,4,4], //"Duel",
[0,7,7,1,2,3,2,4,3,4,1,1,4,2,1,4,3,1,4,1,2,4,2,2,4,1,3], //"Salute",
[0,7,7,1,2,0,2,6,4,4,3,0,4,4,0,4,5,0,4,6,0,4,4,1,4,5,1,4,6,1,4,5,2,4,6,2,4,6,3], //"Stairs",
[0,7,7,1,2,2,2,4,2,4,0,0,4,6,0,4,0,1,4,2,1,4,4,1,4,6,1,4,0,2,4,6,2,4,0,3,4,2,3,4,4,3,4,6,3,4,0,4,4,2,4,4,4,4,4,6,4,4,0,5,4,6,5,4,0,6,4,6,6], //"River",
[0,7,7,3,0,6,4,3,0,4,1,1,4,5,1,4,0,3,4,2,3,4,4,3,4,6,3,4,1,5,4,3,5,4,5,5,4,3,6], //"Firework",
[0,7,7,3,3,3,4,2,0,4,3,0,4,4,0,4,2,1,4,4,1,4,4,2,4,3,5], //"Question",
[0,7,7,3,2,3,4,0,0,4,1,0,4,2,0,4,3,0,4,0,1,4,1,1,4,0,2,4,0,3,4,0,4,4,0,5,4,1,5,4,0,6,4,1,6,4,2,6,4,3,6], //"Crescent",
[0,7,7,1,1,2,2,2,1,4,1,1,4,4,1,4,5,1,4,1,4,4,1,5,4,5,5], //"Umbrella",
[0,7,7,1,3,2,2,3,0,4,0,0,4,1,0,4,2,0,4,4,0,4,5,0,4,6,0,4,1,2,4,5,2,4,1,5,4,5,5], //"Throne",
[0,7,7,1,2,2,2,4,2,4,1,1,4,5,1,4,2,3,4,4,3], //"Fountain",
[0,7,7,1,2,3,2,4,3,4,3,1], //"Triangle",
[0,7,7,1,2,5,2,4,5,4,1,4,4,5,4,4,1,5,4,5,5], //"Devil",
[0,7,7,1,1,4,2,2,5,4,3,1,4,5,1,4,3,3,4,0,5,4,1,5,4,0,6,4,1,6], //"Meteorite",
[0,7,7,1,1,4,2,5,4,4,2,3,4,3,3,4,4,3], //"Sunset",
[0,7,7,1,1,2,2,3,2,4,5,1,4,5,2,4,5,3], //"Password",
[0,7,7,1,1,5,2,5,5,4,1,1,4,2,1,4,3,1,4,4,1,4,5,1,4,1,2,4,5,2,4,1,3,4,5,3], //"Bridge",
[0,7,7,3,3,2,4,3,0], //"Drop",
[0,7,7,1,1,5,2,3,5,4,5,0,4,6,0,4,6,1,4,0,5,4,0,6], //"Trick",
[0,7,7,1,2,4,2,4,4,4,0,0,4,1,0,4,4,0,4,5,0,4,6,0,4,0,1,4,5,1,4,6,1,4,6,2], //"Mountain",
[0,7,7,1,2,2,2,4,2,4,3,4,4,2,5,4,3,5,4,4,5], //"Boss",
[], //"Extra"
];
const colors = [255,255,255, 231,0,91, 0,115,239, 143,0,119, 0,63,23];
var level = 0; // Playing level.
var maxlevel = 0; // Cleared level.
var extra = false; // Playing only extra level flag.
var playing = 1; // Playing count.
var blocking = -1; // Blocking count.
</script><!--/Data-->
<!--Menu--><script>

// Enable or disable menu.
function updateMenu(id, enable, text=null, icon=null) {
	let e = document.getElementById(id);
	if (e) {
		e.style.display = enable ? "flex" : "none";
		let e1 = document.getElementById(id + "Text");
		let e2 = document.getElementById(id + "Icon");
		if (e1 && text) {
			e1.style.display = "flex";
			e1.innerText = text;
			if (e2 && !icon) {
				e2.style.display = "none";
			}
		} else if (e2 && icon) {
			e2.style.display = "flex";
			e2.src = icon;
			if (e1 && !text) {
				e1.style.display = "none";
			}
		} else if (text) {
			e.innerText = text;
		}
	}
}

// Update buttons.
function updateButtons() {
	updateMenu("action", level >= levels.length - 1 || blocking == 0, blocking == 0 ? "^" : "*");
	updateMenu("select", true, level >= levels.length - 1 ? "?" : "" + (level + 1));
	updateMenu("minus", true, level > 0 && !extra ? "-" : " ");
	updateMenu("plus", true, level < maxlevel && !extra ? "+" : " ");
}

// Action button for edit or share level.
async function menuAction() {

	// Share level.
	if (blocking == 0) {
		picoResetParams();
		if (level < levels.length - 1) {
			let password = picoRandom(1000000, (level + 1));
			picoSetStrings("" + (level + 1) + "@" + password, 0);
		} else {
			picoSetCode6(levels[level], 0);
		}
		await picoShare();

	// Enter to edit mode.
	} else {
		picoSetCode6(levels[level], 0);
		picoSetCode8(colors, 1);
		picoSetStrings("bros.html", "u");
		await picoReload("index.html");
	}
}

// Select button for change level.
async function menuSelect(x) {

	// Change level.
	if (x) {
		if (((x > 0 && level + x <= maxlevel) || (x < 0 && level + x >= 0)) && !extra) {
			level = level + x;
			blocking = -1;
			playing = -1; // Restart.
			picoBeep(1.2, 0.1);
		} else {
			picoBeep(0, 0.1);
		}
		updateButtons();
		picoFlush();

	// Restart level.
	} else /*if (level < levels.length - 1)*/ {
		blocking = -1;
		playing = -1; // Restart.
		picoBeep(1.2, 0.1);
		updateButtons();

	// Enter to edit mode.
	/*} else {
		picoSetCode6(levels[level], 0);
		picoSetCode8(colors, 1);
		picoSetStrings("bros.html", "u");
		await picoReload("index.html");*/
	}
}
</script><!--/Menu-->
<!--Main--><script>
async function main() {

	// Load query params.
	let value = picoStrings();
	if (value) {

		// Load extra level.
		if (value[0] == "0") {
			levels[levels.length - 1] = picoCode6();
			level = levels.length - 1;
			extra = true;

		// Load max level.
		} else {
			let numbers = picoNumbers();
			if (numbers[0] >= 0 && numbers[0] < levels.length &&
			picoRandom(1000000, numbers[0]) == numbers[1]) {
				maxlevel = numbers[0];
				level = numbers[0] - 1;
			}
		}
	}
	updateButtons();

	// Load pallete data.
	picoColor(colors);

	// Main loop.
	for (;;) {

		// Initial param.
		const maxsize = 24; // Max size.
		let width = 7, height = 7; // Field size.
		let grid = 24, margin = 2, primary = 0;
		let pixels = [[],[],[],[],[],[],[]];
		let players = [[], []];

		// Load level data.
		if (levels[level]) {
			for (let k = 0; k < levels[level].length / 3; k++) {
				let w = levels[level][k * 3];
				let x = levels[level][k * 3 + 1];
				let y = levels[level][k * 3 + 2];
				if (w == 0) {
					width = x >= 0 && x <= maxsize ? x : 7;
					height = y >= 0 && y <= maxsize ? y : 7;
					grid = 168 / width;
					margin = width <= 9 ? 2 : 1;
					players = [[0, 0], [width - 1, height - 1]];
					for (let j = 0; j < height; j++) {
						pixels[j] = [];
						for (let i = 0; i < width; i++) {
							pixels[j][i] = 0;
						}
					}
					blocking = width * height;
				} else if (w >= 1 && w <= 4 && x >= 0 && x < width && y >= 0 && y < height) {
					if (w >= 1 && w <= 2) {
						if (pixels[players[w - 1][1]][players[w - 1][0]] >= 3) {
							pixels[players[w - 1][1]][players[w - 1][0]] -= w;
						} else {
							pixels[players[w - 1][1]][players[w - 1][0]] = 0;
						}
						players[w - 1] = [x, y];
					} else if (w == 3) {
						pixels[players[0][1]][players[0][0]] = 0;
						pixels[players[1][1]][players[1][0]] = 0;
						players[0] = [x, y];
						players[1] = [x, y];
					}
					pixels[y][x] = w;
					blocking -= 1;
				}
			}
		}

		// Playing loop.
		for (playing = 1; playing > 0; playing++) {
			picoClear();

			// Move player.
			for (let j = 0; j < height; j++) {
				let y = (j - (height - 1) / 2) * grid;
				for (let i = 0; i < width; i++) {
					let x = (i - (width - 1) / 2) * grid;

					// Touch blank cell to move player.
					if (pixels[j][i] == 0) {
						if (picoMotion(x, y, grid/2)) {
							// Check cell next to player.
							let next = [false, false];
							for (let k = 0; k < 2; k++) {
								let dx = i - players[k][0], dy = j - players[k][1];
								if (dx * dy == 0 && (dx + dy == -1 || dx + dy == 1)) {
									next[k] = true;
								}
							}
							// Check facing cell between 2 players.
							let dx = players[0][0] - players[1][0], dy = players[0][1] - players[1][1];
							let next2 = dx * dy == 0 && (dx + dy == 2 || dx + dy == -2) ? true : false;
							// P1 and P2 move into same cell.
							if (next[0] && next[1] && next2) {
								pixels[j][i] = 3;
								players[0] = players[1] = [i, j];
								blocking -= 1;
							} else {
								// Move primary player first.
								for (let k = 0; k < 2; k++) {
									let k1 = primary == 0 ? k : k ? 0 : 1, k2 = k1 ? 0 : 1;
									// Player A moves forward and another player B moves backward.
									if (next[k1]) {
										pixels[j][i] = k1 == 0 ? 1 : 2;
										let i2 = players[k2][0] + players[k1][0] - i;
										let j2 = players[k2][1] + players[k1][1] - j;
										if (i2 >= 0 && i2 < width && j2 >= 0 && j2 < height) {
											if (pixels[j2][i2] == 0) {
												pixels[j2][i2] = k2 == 0 ? 1 : 2;
												players[k2] = [i2, j2];
												blocking -= 1;
											}
										}
										players[k1] = [i, j];
										blocking -= 1;
										break; // Only one player moves forward.
									}
								}
							}
						}
						//updateMenu("subtitle", true, "" + blocking);

						// Clear level.
						if (blocking == 0) {
							players = [[], []];
							maxlevel = level + 1 < levels.length ? level + 1 : levels.length;
							picoBeep(1.2, 0.1);
							picoBeep(1.2, 0.1, 0.2);
							updateButtons();
						}
					}
				}
			}

			// Draw player.
			for (let j = 0; j < height; j++) {
				let y = (j - (height - 1) / 2) * grid;
				for (let i = 0; i < width; i++) {
					let x = (i - (width - 1) / 2) * grid;
					let expand = false;
	
					// Touch color cell to update primary player.
					if (pixels[j][i] != 0) {
						if (picoMotion(x, y, (grid+margin)/2)) {
							if (pixels[j][i] == 1) {
								primary = 0;
							} else if (pixels[j][i] == 2) {
								primary = 1;
							}

						// Set scale for touching or not touching player.
						} else {
							for (let k = 0; k < 2; k++) {
								if (i == players[k][0] && j == players[k][1]) {
									expand = true;
									break;
								}
							}
						}
					}

					// Draw cell.
					if (expand) {
						picoPixel(pixels[j][i], x, y, (grid+margin)/2, (grid+margin)/2);
					} else {
						picoPixel(pixels[j][i], x, y, (grid-margin)/2-1, (grid-margin)/2-1);
					}
				}
			}

			await picoFlip();
			await picoRead();
		} // End of playing loop.
	} // End of main loop.
};
main();
</script><!--/Main-->
</body>
</html>
